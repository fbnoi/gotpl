package main

import (
	"gotpl/template"
)

type Node interface {
	Pos() template.Pos // position of first character belonging to the node
	End() template.Pos // position of first character immediately after the node
}

// All expression nodes implement the Expr interface.
type Expr interface {
	Node
	exprNode()
}

// All statement nodes implement the Stmt interface.
type Stmt interface {
	Node
	stmtNode()
}

// All textext nodes implement the Text interface.
type Text interface {
	Node
	textNode()
}

// ----------------------------------------------------------------------------
// Expressions

type (
	Ident struct {
		NamePos template.Pos // identifier position
		Name    string       // identifier name
	}

	BasicLit struct {
		ValuePos template.Pos // literal position
		Kind     int          // template.TYPE_NUMBER, template.TYPE_STRING
		Value    string       // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
	}

	OpLit struct {
		OpPos template.Pos // literal position
		Kind  int          // template.TYPE_OPERATOR, template.TYPE_NAME
		Op    string       // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
	}

	// An IndexExpr node represents an expression followed by an index.
	IndexExpr struct {
		X      Expr         // expression
		Lbrack template.Pos // position of "["
		Index  Expr         // index expression
		Rbrack template.Pos // position of "]"
	}

	// A CallExpr node represents an expression followed by an argument list.
	CallExpr struct {
		Fun    Expr         // function expression
		Lparen template.Pos // position of "("
		Args   []Expr       // function arguments; or nil
		Rparen template.Pos // position of ")"
	}

	// A BinaryExpr node represents a binary expression.
	BinaryExpr struct {
		X     Expr         // left operand
		OpPos template.Pos // position of Op
		Op    OpLit        // operator
		Y     Expr         // right operand
	}
)

// Pos and End implementations for expression/type nodes.

func (x *Ident) Pos() template.Pos      { return x.NamePos }
func (x *BasicLit) Pos() template.Pos   { return x.ValuePos }
func (x *OpLit) Pos() template.Pos      { return x.OpPos }
func (x *IndexExpr) Pos() template.Pos  { return x.X.Pos() }
func (x *CallExpr) Pos() template.Pos   { return x.Fun.Pos() }
func (x *BinaryExpr) Pos() template.Pos { return x.X.Pos() }

func (x *Ident) End() template.Pos      { return template.Pos(int(x.NamePos) + len(x.Name)) }
func (x *BasicLit) End() template.Pos   { return template.Pos(int(x.ValuePos) + len(x.Value)) }
func (x *OpLit) End() template.Pos      { return template.Pos(int(x.OpPos) + len(x.Op)) }
func (x *IndexExpr) End() template.Pos  { return x.Rbrack + 1 }
func (x *CallExpr) End() template.Pos   { return x.Rparen + 1 }
func (x *BinaryExpr) End() template.Pos { return x.Y.End() }

// exprNode() ensures that only expression/type nodes can be
// assigned to an Expr.
//
func (*Ident) exprNode()      {}
func (*BasicLit) exprNode()   {}
func (*OpLit) exprNode()      {}
func (*IndexExpr) exprNode()  {}
func (*CallExpr) exprNode()   {}
func (*BinaryExpr) exprNode() {}

// ----------------------------------------------------------------------------
// Convenience functions for Idents

// NewIdent creates a new Ident without position.
// Useful for ASTs generated by code other than the Go parser.
//
func NewIdent(name string) *Ident { return &Ident{template.NoPos, name} }

func (id *Ident) String() string {
	if id != nil {
		return id.Name
	}
	return "<nil>"
}

// ----------------------------------------------------------------------------
// Statements

type (
	// TextStmt
	TextStmt struct {
		Text Expr // text content BasicLit
	}

	ValueStmt struct {
		Tok Expr // assignment expr
	}

	// An AssignStmt node represents an assignment or
	// a short variable declaration.
	//
	AssignStmt struct {
		Lh     Expr
		TokPos template.Pos   // position of Tok
		Tok    template.Token // assignment token, DEFINE
		Rh     Expr
	}

	// A SectionStmt node represents a braced statement list.
	SectionStmt struct {
		List []Stmt
	}

	// An IfStmt node represents an if statement.
	IfStmt struct {
		If   template.Pos // position of "if" keyword
		Cond Expr         // condition
		Else Stmt         // else branch; or nil
		Body *SectionStmt
	}

	// A ForStmt represents a for statement.
	ForStmt struct {
		For  template.Pos // position of "for" keyword
		Init Stmt         // initialization statement; or nil
		Cond Expr         // condition; or nil
		Post Stmt         // post iteration statement; or nil
		Body *SectionStmt
	}

	// A RangeStmt represents a for statement with a range clause.
	RangeStmt struct {
		For        template.Pos   // position of "for" keyword
		Key, Value Expr           // Key, Value may be nil
		TokPos     template.Pos   // position of Tok; invalid if Key == nil
		Tok        template.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
		X          Expr           // value to range over
		Body       *SectionStmt
	}

	//
	BlockStmt struct {
		Name string
		Body *SectionStmt
	}
)

// Pos and End implementations for statement nodes.
func (s *TextStmt) Pos() template.Pos   { return s.Text.Pos() }
func (s *ValueStmt) Pos() template.Pos  { return s.Tok.Pos() }
func (s *AssignStmt) Pos() template.Pos { return s.Lh.Pos() }
func (s *SectionStmt) Pos() template.Pos {
	if len(s.List) > 0 {
		return s.List[0].Pos()
	}
	return template.NoPos
}
func (s *IfStmt) Pos() template.Pos     { return s.If }
func (s *ForStmt) Pos() template.Pos    { return s.For }
func (s *RangeStmt) Pos() template.Pos  { return s.For }
func (s *BlockStmt) Pos() template.Pos  { return s.Body.Pos() }
func (s *TextStmt) End() template.Pos   { return s.Text.End() }
func (s *ValueStmt) End() template.Pos  { return s.Tok.End() }
func (s *AssignStmt) End() template.Pos { return s.Rh.End() }
func (s *SectionStmt) End() template.Pos {
	if len(s.List) > 0 {
		return s.List[len(s.List)-1].Pos()
	}
	return template.NoPos
}
func (s *IfStmt) End() template.Pos {
	if s.Else != nil {
		return s.Else.End()
	}
	return s.Body.End()
}
func (s *ForStmt) End() template.Pos   { return s.Body.End() }
func (s *RangeStmt) End() template.Pos { return s.Body.End() }
func (s *BlockStmt) End() template.Pos { return s.Body.End() }

// stmtNode() ensures that only statement nodes can be
// assigned to a Stmt.
//

func (*TextStmt) stmtNode()    {}
func (*ValueStmt) stmtNode()   {}
func (*AssignStmt) stmtNode()  {}
func (*SectionStmt) stmtNode() {}
func (*IfStmt) stmtNode()      {}
func (*ForStmt) stmtNode()     {}
func (*RangeStmt) stmtNode()   {}
func (*BlockStmt) stmtNode()   {}
